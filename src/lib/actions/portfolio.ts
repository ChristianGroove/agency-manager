"use server"

import { createClient } from "@/lib/supabase-server"
import { ServiceCatalogItem } from "@/types"
import { revalidatePath } from "next/cache"
import { slugify } from "@/lib/utils"

export async function getPortfolioItems() {
    const supabase = await createClient()
    const { data, error } = await supabase
        .from('service_catalog')
        .select('*')
        .order('category')
        .order('name')

    if (error) throw error
    return data as ServiceCatalogItem[]
}

export async function upsertPortfolioItem(item: Partial<ServiceCatalogItem>) {
    const supabase = await createClient()
    const { data: { user } } = await supabase.auth.getUser()

    if (!user) {
        throw new Error("Unauthorized")
    }

    // 1. Upsert Service Catalog Item
    const { data: serviceData, error: serviceError } = await supabase
        .from('service_catalog')
        .upsert({
            id: item.id, // If ID exists, it updates. If null/undefined, it inserts (if handled by DB default, but usually we need to omit ID for insert or verify DB setup. Assuming UUID is generated by DB if omitted)
            // Ideally we separate Create and Update or handle ID generation if client doesn't provide it.
            // Let's assume we pass undefined ID for new creation on client side and let Supabase handle it if we don't include it in 'upsert' payload if it's new.
            // However, upsert requires a primary key match. If no ID, we should insert.
            ...(item.id ? { id: item.id } : {}),
            name: item.name,
            description: item.description,
            category: item.category,
            type: item.type,
            frequency: item.frequency,
            base_price: item.base_price,
            is_visible_in_portal: item.is_visible_in_portal
        })
        .select()
        .single()

    if (serviceError) throw serviceError

    // 2. Sync with Briefing Template
    // We try to find a template with the same slug or name.
    const slug = slugify(item.name || "")

    // Check if template exists by slug (assuming slug is unique or we use it as key)
    // Or check by Name if slug isn't reliable.
    const { data: existingTemplate } = await supabase
        .from('briefing_templates')
        .select('id')
        .eq('slug', slug)
        .single()

    if (existingTemplate) {
        // Update existing template
        await supabase
            .from('briefing_templates')
            .update({
                name: item.name,
                description: item.description,
                updated_at: new Date().toISOString()
            })
            .eq('id', existingTemplate.id)
    } else {
        // Create new template
        await supabase
            .from('briefing_templates')
            .insert({
                name: item.name,
                description: item.description,
                slug: slug,
                // We might need to handle 'steps' initialization here if we want a default template structure?
                // For now, user just asked to create the template. We'll create it empty.
            })
    }

    revalidatePath('/dashboard/portfolio')
    revalidatePath('/dashboard/quotes/new')
    // Revalidate other paths where catalog is used
    return serviceData
}

export async function deletePortfolioItem(id: string) {
    const supabase = await createClient()

    // We only delete the service catalog item. 
    // We DO NOT delete the Briefing Template automatically as it might have historical briefs attached.
    // This is a safety decision.

    const { error } = await supabase
        .from('service_catalog')
        .delete()
        .eq('id', id)

    if (error) throw error
    revalidatePath('/dashboard/portfolio')
}
