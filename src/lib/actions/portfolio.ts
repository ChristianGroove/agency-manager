"use server"

import { createClient } from "@/lib/supabase-server"
import { ServiceCatalogItem } from "@/types"
import { revalidatePath } from "next/cache"
import { slugify } from "@/lib/utils"

export async function getPortfolioItems() {
    const supabase = await createClient()
    const { data, error } = await supabase
        .from('service_catalog')
        .select('*')
        .order('category')
        .order('name')

    if (error) throw error
    return data as ServiceCatalogItem[]
}

export async function upsertPortfolioItem(item: Partial<ServiceCatalogItem>) {
    const supabase = await createClient()
    const { data: { user } } = await supabase.auth.getUser()

    if (!user) {
        throw new Error("Unauthorized")
    }

    // 1. Upsert Service Catalog Item
    const { data: serviceData, error: serviceError } = await supabase
        .from('service_catalog')
        .upsert({
            id: item.id, // If ID exists, it updates. If null/undefined, it inserts (if handled by DB default, but usually we need to omit ID for insert or verify DB setup. Assuming UUID is generated by DB if omitted)
            // Ideally we separate Create and Update or handle ID generation if client doesn't provide it.
            // Let's assume we pass undefined ID for new creation on client side and let Supabase handle it if we don't include it in 'upsert' payload if it's new.
            // However, upsert requires a primary key match. If no ID, we should insert.
            ...(item.id ? { id: item.id } : {}),
            name: item.name,
            description: item.description,
            category: item.category,
            type: item.type,
            frequency: item.frequency,
            base_price: item.base_price,
            is_visible_in_portal: item.is_visible_in_portal
        })
        .select()
        .single()

    if (serviceError) throw serviceError

    // 2. Sync with Briefing Template
    // We try to find a template with the same slug or name.
    const slug = slugify(item.name || "")

    // Check if template exists by slug (assuming slug is unique or we use it as key)
    // Or check by Name if slug isn't reliable.
    const { data: existingTemplate } = await supabase
        .from('briefing_templates')
        .select('id')
        .eq('slug', slug)
        .single()

    if (existingTemplate) {
        // Update existing template
        await supabase
            .from('briefing_templates')
            .update({
                name: item.name,
                description: item.description,
                updated_at: new Date().toISOString()
            })
            .eq('id', existingTemplate.id)
    } else {
        // Create new template
        await supabase
            .from('briefing_templates')
            .insert({
                name: item.name,
                description: item.description,
                slug: slug,
                // We might need to handle 'steps' initialization here if we want a default template structure?
                // For now, user just asked to create the template. We'll create it empty.
            })
    }

    revalidatePath('/dashboard/portfolio')
    revalidatePath('/dashboard/quotes/new')
    // Revalidate other paths where catalog is used
    return serviceData
}

export async function deletePortfolioItem(id: string) {
    const supabase = await createClient()

    // We only delete the service catalog item. 
    // We DO NOT delete the Briefing Template automatically as it might have historical briefs attached.
    // This is a safety decision.

    const { error } = await supabase
        .from('service_catalog')
        .delete()
        .eq('id', id)

    if (error) throw error
    revalidatePath('/dashboard/portfolio')
}


// Helper for Template Configuration
const TEMPLATE_CONFIG: Record<string, { title: string, description: string, fields: any[] }[]> = {
    'Branding': [
        {
            title: "Identidad de Marca",
            description: "Define el alma y la apariencia de tu marca.",
            fields: [
                { label: "¿Cuál es la misión y visión de la empresa?", name: "mision_vision", type: "textarea", required: true, order: 1 },
                { label: "Describe a tu cliente ideal (Avatar)", name: "target_audience", type: "textarea", required: true, order: 2 },
                { label: "Adjetivos que describan la marca (Ej: Seria, Juvenil)", name: "brand_adjectives", type: "text", required: true, order: 3 },
                { label: "Preferencias de color", name: "color_preferences", type: "text", required: false, order: 4 },
                { label: "¿Qué marcas admiras? (Referencias)", name: "references", type: "textarea", required: false, order: 5 }
            ]
        }
    ],
    'Desarrollo Web': [
        {
            title: "Objetivos del Sitio",
            description: "Estructura y funcionalidad esperada.",
            fields: [
                { label: "¿Cuál es el objetivo principal? (Ventas, Informativo, Portafolio)", name: "site_objective", type: "text", required: true, order: 1 },
                { label: "Secciones requeridas (Inicio, Nosotros, Contacto...)", name: "sitemap", type: "textarea", required: true, order: 2 },
                { label: "Sitios web de referencia (Links)", name: "ref_sites", type: "textarea", required: true, order: 3 },
                { label: "¿Cuentas con Hosting/Dominio?", name: "hosting_domain", type: "radio", options: ["Si", "No", "Necesito Asesoría"], required: true, order: 4 }
            ]
        }
    ],
    'Marketing': [
        {
            title: "Estrategia de Campaña",
            description: "Detalles para la configuración de anuncios.",
            fields: [
                { label: "Presupuesto Mensual Estimado", name: "budget", type: "text", required: true, order: 1 },
                { label: "Objetivo de Campaña", name: "campaign_objective", type: "select", options: ["Reconocimiento", "Tráfico", "Leads", "Ventas"], required: true, order: 2 },
                { label: "Público Objetivo (Ubicación, Edad, Intereses)", name: "audience_details", type: "textarea", required: true, order: 3 },
                { label: "Material Creativo Disponible", name: "creatives", type: "checkbox", options: ["Fotos", "Videos", "Logos", "No tengo material"], required: false, order: 4 }
            ]
        }
    ],
    'Default': [
        {
            title: "Detalles del Proyecto",
            description: "Información general sobre el requerimiento.",
            fields: [
                { label: "Descripción detallada del requerimiento", name: "project_description", type: "textarea", required: true, order: 1 },
                { label: "¿Cuál es el objetivo principal?", name: "main_objective", type: "text", required: true, order: 2 },
                { label: "Fecha de entrega esperada", name: "deadline", type: "date", required: false, order: 3 },
                { label: "Archivos adjuntos o referencias", name: "attachments", type: "textarea", required: false, order: 4 }
            ]
        }
    ]
}

export async function syncAllBriefingTemplates() {
    const supabase = await createClient()

    // 1. Get all services
    const { data: services } = await supabase.from('service_catalog').select('*')
    if (!services) return

    let createdCount = 0

    // 2. Iterate services to Ensure Template Exists AND has Steps
    for (const service of services) {
        const slug = slugify(service.name)

        // A. Upsert Template to ensure it exists
        // We use upsert to create it if missing, or get its ID if existing
        const { data: template, error: tmplError } = await supabase
            .from('briefing_templates')
            .upsert({
                name: service.name,
                description: service.description || `Plantilla para ${service.name}`,
                slug: slug,
                updated_at: new Date().toISOString()
            }, { onConflict: 'slug' })
            .select('id')
            .single()

        if (tmplError || !template) {
            console.error("Error upserting template:", tmplError)
            continue
        }

        // B. Check if steps exist
        const { count } = await supabase
            .from('briefing_steps')
            .select('*', { count: 'exact', head: true })
            .eq('template_id', template.id)

        // Only populate if NO steps exist (to avoid overwriting custom ones)
        if (count === 0) {
            // Determine config
            let config = TEMPLATE_CONFIG['Default']
            const lowerName = service.name.toLowerCase()
            const lowerCat = service.category.toLowerCase()

            if (lowerCat.includes('branding') || lowerName.includes('brand') || lowerName.includes('identidad')) config = TEMPLATE_CONFIG['Branding']
            else if (lowerCat.includes('web') || lowerName.includes('web') || lowerName.includes('landing') || lowerName.includes('ecommerce')) config = TEMPLATE_CONFIG['Desarrollo Web']
            else if (lowerCat.includes('marketing') || lowerName.includes('ads') || lowerName.includes('pauta')) config = TEMPLATE_CONFIG['Marketing']

            // Insert Steps and Fields
            for (const [stepIndex, stepConfig] of config.entries()) {
                const { data: newStep, error: stepError } = await supabase
                    .from('briefing_steps')
                    .insert({
                        template_id: template.id,
                        title: stepConfig.title,
                        description: stepConfig.description,
                        order_index: stepIndex + 1
                    })
                    .select()
                    .single()

                if (stepError || !newStep) continue

                const fieldsToInsert = stepConfig.fields.map(f => ({
                    step_id: newStep.id,
                    label: f.label,
                    name: f.name,
                    type: f.type,
                    required: f.required,
                    options: f.options || null,
                    order_index: f.order
                }))

                await supabase.from('briefing_fields').insert(fieldsToInsert)
            }
            createdCount++
        }
    }

    if (createdCount > 0) {
        revalidatePath('/dashboard/portfolio')
        revalidatePath('/dashboard/briefings')
    }

    return { success: true, count: createdCount }
}
